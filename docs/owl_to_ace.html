<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Verbalizing OWL in ACE</title>
<meta name="Author" content="Kaarel Kaljurand"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<script type="text/javascript" src="http://attempto.ifi.uzh.ch/site/script/toc.js"></script>
<link rel="stylesheet" title="default" href="http://attempto.ifi.uzh.ch/site/css/ace.css" media="screen" type="text/css"/>

<style type="text/css">
.form { border: silver 1px solid; background-color: #fff090; padding: 0em 1em 0em 1em }
</style>
</head>


<body onload="toc(1, 0)">

<h1>OWL verbalizer demo</h1>

<h2>Introduction</h2>

<p>This demo shows how an ontology that is written in
<a href="http://www.w3.org/TR/owl2-xml-serialization/">OWL 2 XML</a> is
verbalized in Attempto Controlled English (ACE).
This conversion is designed to be reversible, i.e.
one can convert the ACE representation back into OWL so that no loss in meaning
occurs.</p>

<p>The source code, issue list, documentation etc. of the OWL verbalizer
are available at
<a href="http://code.google.com/p/owlverbalizer/">code.google.com/p/owlverbalizer/</a>.</p>


<h2>Demo</h2>

<div class="form">
<!-- <form action="http://attempto.ifi.uzh.ch/service/owl_verbalizer/owl_to_ace" method="post"> -->
<form action="http://localhost:8000" method="post">

<p>Enter the content of an OWL ontology in the OWL 2 XML format.
<br/>(You can use
<a href="http://owl.cs.manchester.ac.uk/converter/">OWL Syntax Converter</a>
to convert from RDF/XML, Turtle, etc. into OWL 2 XML.)</p>

<div>
<textarea name="xml" title="OWL ontology in XML syntax" rows="24" cols="80">
&lt;?xml version="1.0"?>
&lt;Ontology xmlns="http://www.w3.org/2002/07/owl#"
     xml:base="http://org.semanticweb.ontologies/test"
         xmlns:xml="http://www.w3.org/XML/1998/namespace">

    &lt;Prefix name="story" IRI="http://www.example.org/story.owl#"/>
    &lt;Prefix name="ace_lexicon" IRI="http://attempto.ifi.uzh.ch/ace_lexicon#"/>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:TV_sg"/>
                &lt;IRI>http://www.example.org/story.owl#eat&lt;/IRI>
        &lt;Literal>eats&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:TV_pl"/>
                &lt;IRI>http://www.example.org/story.owl#eat&lt;/IRI>
        &lt;Literal>eat&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:TV_vbg"/>
                &lt;IRI>http://www.example.org/story.owl#eat&lt;/IRI>
        &lt;Literal>eaten&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:CN_sg"/>
                &lt;IRI>http://www.example.org/story.owl#hate&lt;/IRI>
        &lt;Literal>hater&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:CN_pl"/>
                &lt;IRI>http://www.example.org/story.owl#leaf&lt;/IRI>
        &lt;Literal>leaves&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;SubClassOf>
        &lt;Class abbreviatedIRI="story:animal"/>
        &lt;ObjectUnionOf>
            &lt;Class abbreviatedIRI="story:cat"/>
            &lt;Class abbreviatedIRI="story:goat"/>
        &lt;/ObjectUnionOf>
    &lt;/SubClassOf>
    &lt;EquivalentClasses>
        &lt;Class abbreviatedIRI="story:goat"/>
        &lt;ObjectAllValuesFrom>
            &lt;ObjectProperty abbreviatedIRI="story:eat"/>
            &lt;Class abbreviatedIRI="story:leaf"/>
        &lt;/ObjectAllValuesFrom>
    &lt;/EquivalentClasses>
    &lt;SubClassOf>
        &lt;Class abbreviatedIRI="story:human"/>
        &lt;ObjectIntersectionOf>
            &lt;Class abbreviatedIRI="story:person"/>
            &lt;ObjectSomeValuesFrom>
                &lt;ObjectProperty abbreviatedIRI="story:own"/>
                &lt;Class abbreviatedIRI="story:automobile"/>
            &lt;/ObjectSomeValuesFrom>
        &lt;/ObjectIntersectionOf>
    &lt;/SubClassOf>
    &lt;SubClassOf>
        &lt;Class abbreviatedIRI="story:human"/>
        &lt;ObjectOneOf>
            &lt;NamedIndividual abbreviatedIRI="story:John"/>
            &lt;NamedIndividual abbreviatedIRI="story:Mary"/>
        &lt;/ObjectOneOf>
    &lt;/SubClassOf>
    &lt;SubClassOf>
        &lt;Class abbreviatedIRI="story:man"/>
        &lt;Class abbreviatedIRI="story:person"/>
    &lt;/SubClassOf>
    &lt;FunctionalObjectProperty>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
    &lt;/FunctionalObjectProperty>
    &lt;InverseFunctionalObjectProperty>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
    &lt;/InverseFunctionalObjectProperty>
    &lt;TransitiveObjectProperty>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
    &lt;/TransitiveObjectProperty>
    &lt;ObjectPropertyDomain>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
        &lt;Class abbreviatedIRI="story:animal"/>
    &lt;/ObjectPropertyDomain>
    &lt;ObjectPropertyRange>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
        &lt;ObjectIntersectionOf>
            &lt;Class abbreviatedIRI="story:food"/>
            &lt;ObjectComplementOf>
                &lt;Class abbreviatedIRI="story:automobile"/>
            &lt;/ObjectComplementOf>
        &lt;/ObjectIntersectionOf>
    &lt;/ObjectPropertyRange>
    &lt;InverseObjectProperties>
        &lt;ObjectProperty abbreviatedIRI="story:hate"/>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
    &lt;/InverseObjectProperties>
    &lt;ClassAssertion>
        &lt;Class abbreviatedIRI="story:man"/>
        &lt;NamedIndividual abbreviatedIRI="story:John"/>
    &lt;/ClassAssertion>
    &lt;SubClassOf>
        &lt;ObjectUnionOf>
            &lt;Class abbreviatedIRI="story:apple"/>
            &lt;Class abbreviatedIRI="story:leaf"/>
        &lt;/ObjectUnionOf>
        &lt;Class abbreviatedIRI="story:food"/>
    &lt;/SubClassOf>
&lt;/Ontology>
</textarea>
</div>

<p>Specify the output format</p>

<div>
<input type="radio" name="format" value="ace" checked="checked"/>
plain ACE text (text/plain)
<br/>
<input type="radio" name="format" value="html"/>
HTML table of Axiom-Sentences mappings (text/html)
<br/>
<input type="radio" name="format" value="csv"/>
tokenized and without lexicon lookup in 2-column CSV (text/plain)
</div>

<p>... and press <input type="submit" value="Verbalize" title="Verbalize the ontology!"/></p>
</form>

<p>If the ontology contains a syntax error or
takes too long to verbalize then an error message is returned.</p>
</div>


<h2>How is the verbalization done?</h2>

<p>We first rewrite the class expressions and axioms via a limited number of
more basic class expressions and axioms. The motivation behind this step is
to replace axioms like</p>

<pre>
ObjectPropertyDomain(R C)
</pre>

<p>which have very little syntactic structure and contain logic-specific words
like `domain'.</p>

<p>The remaining class expressions are mapped to ACE noun phrases and the remaining
axioms to ACE sentences. OWL properties are ACE verbs or <em>of</em>-constructs
and OWL individuals are
ACE proper names. The following table shows an example
how the OWL constructs are mapped to ACE constructs.</p>

<table>
	<thead>
		<tr>
			<td>OWL</td>
			<td>ACE</td>
		</tr>
	</thead>

	<tbody>
		<tr>
			<td><em>Named property</em></td>
			<td><em>Transitive verb, e.g.</em> own<em>; or of-construct, e.g.</em> father of</td>
		</tr>
		<tr>
			<td>ObjectInverseOf(R)</td>
			<td><em>Passive verb, e.g.</em> is owned by<em>; or Saxon genitive, e.g.</em> X's father</td>
		</tr>
		<tr>
			<td><em>Named class</em></td>
			<td><em>Common noun, e.g.</em> person</td>
		</tr>

		<tr>
			<td>owl:Thing</td>
			<td>something, thing, X, Y, ...</td>
		</tr>

		<tr>
			<td>ObjectComplementOf(C)</td>
			<td>something that <b>is not</b> a person; something that <b>does not</b> own a car</td>
		</tr>

		<tr>
			<td>ObjectIntersectionOf(C1 ... Cn)</td>
			<td>something that is a person <b>and</b> that owns a car</td>
		</tr>

		<tr>
			<td>ObjectUnionOf(C1 ... Cn)</td>
			<td>something that is a wild-animal <b>or</b> that is a zoo-animal</td>
		</tr>

		<tr>
			<td>ObjectOneOf(a)</td>
			<td><em>Proper name, e.g.</em> John</td>
		</tr>

		<tr>
			<td>ObjectSomeValuesFrom(R C)</td>
			<td>something that owns <b>a</b> car</td>
		</tr>

		<tr>
			<td>ObjectHasSelf(R)</td>
			<td>something that likes <b>itself</b></td>
		</tr>

		<tr>
			<td>ObjectMinCardinality(n R C)</td>
			<td>something that borders <b>at least 2</b> countries</td>
		</tr>

		<tr>
			<td>SubClassOf(C D)</td>
			<td><b>Every</b> country that borders no bodies-of-water <b>is</b> a landlocked-country.</td>
		</tr>

		<tr>
			<td>SubObjectPropertyOf(ObjectPropertyChain(R1 ... Rn) S)</td>
			<td><b>If</b> X owns something that is-part-of Y <b>then</b> X owns Y.</td>
		</tr>

		<tr>
			<td>DisjointObjectProperties(R S)</td>
			<td><b>If</b> X is-child-of Y <b>then</b> <b>it is false that</b> X is-spouse-of Y.</td>
		</tr>
	</tbody>
</table>

<p>ACE allows relative clause coordination and embedding of relative clauses into
other relative clauses. This gives us quite a bit of flexibility in expressing more
complex OWL class expressions. For example,</p>

<pre>
ObjectSomeValuesFrom(eat ObjectComplementOf(ice-cream))
</pre>

<p>would be verbalized as an ACE noun phrase</p>

<pre>
something that eats something that is not an ice-cream
</pre>

<p>Still, verbalizing very complex class expressions would require a support for parentheses which
ACE does not offer. We do not see it as a shortcoming, rather it is a natural
restriction on the complexity of class expressions (which should be readable for
others to understand).</p>

<p>Finally, we apply some simple modifications to make the sentences more
readable, e.g. we try to remove negations and reorder the elements in coordination.</p>


<h2>OWL entities vs ACE content words</h2>

<p>The quality of the verbalization depends somewhat on the morphologic and orthographic
nature of the names
used for individuals, classes and properties in the input ontology. The verbalizer assumes
that all individuals are denoted by singular proper names (preferably capitalized),
classes by singular common nouns, and properties by transitive verbs in
their infinitive form or as singular nouns.
These restrictions are needed because the names will be used in certain
syntactic constructions or will undergo certain morphological changes.</p>

<ul>
<li>Individuals (proper names) are used in the subject and object positions
without a determiner, e.g. "Every man knows <b>John</b>.",
"<b>John</b> is a man."</li>
<li>Classes (common nouns) are used in the subject and object positions with
determiners like <i>every</i>, <i>no</i>, <i>a</i>, <i>at least 2</i>;
e.g. "Every <b>man</b> knows something.",
"No <b>woman</b> likes a <b>spider</b>.",
"Every <b>baltic-state</b> borders at least 2 <b>countries</b>.".</li>
<li>Properties (transitive verbs) are often used in singular, e.g.
"Every boy <b>owns</b> a bike.", but under negation (i.e. <em>ObjectComplementOf</em>)
will stay in infinitive, e.g. "Every one-year-old is a child that does not <b>own</b> a bike.".
In some cases, most often when verbalizing the <em>ObjectPropertyRange</em>-construct,
a past participle form is used in order to construct a passive sentence, e.g.
"Everything that is <b>owned</b> by something is a possession."</li>
</ul>

<p>The default synthesis of entity IRI surface forms just preserves
the IRI fragment (the part after '#' or the last '/')
but one can add annotations to the input ontology
to specify the desired surface form, e.g.</p>

<pre>
&lt;AnnotationAssertion> 
	&lt;AnnotationProperty IRI="http://attempto.ifi.uzh.ch/ace_lexicon#CN_pl"/>
	&lt;IRI>#man&lt;/IRI>
	&lt;Literal>men&lt;/Literal>
&lt;/AnnotationAssertion>
</pre>

<p>The following annotation properties are supported:</p>

<table>
	<thead>
		<tr>
			<td>Annotation property IRI</td>
			<td>Meaning</td>
			<td>Example IRI</td>
			<td>Example literal</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#PN_sg</code></td>
			<td>singular form of a proper name</td>
			<td>#John</td>
			<td>John</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#CN_sg</code></td>
			<td>singular form of a common noun</td>
			<td>#man</td>
			<td>man</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#CN_pl</code></td>
			<td>plural form of a common noun</td>
			<td>#man</td>
			<td>men</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#TV_sg</code></td>
			<td>singular form of a transitive verb</td>
			<td>#man</td>
			<td>mans</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#TV_pl</code></td>
			<td>plural form of a transitive verb</td>
			<td>#man</td>
			<td>man</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#TV_vbg</code></td>
			<td>past participle form a transitive verb</td>
			<td>#man</td>
			<td>manned</td>
		</tr>
	</tbody>
</table>

<p>In the csv-mode, the IRI is returned as it is together with the morphological
type that applies in the given context, e.g:</p>

<pre>
pn_sg	http://www.example.org/story.owl#John
f	is
f	a
cn_sg	http://www.example.org/story.owl#man
f	.
</pre>

<p>In the ace-mode, in case an object property has the <code>CN_sg</code> annotation
then the property is verbalized as a relational noun, using an <em>of</em>-construct,
Saxon genitive, or the <em>whose</em> relative pronoun. Examples:</p>

<pre>
John is a father of Mary.
Mary's father is John.
Everything whose father is John ...
</pre>

<p>This is an experimental feature which does not always work correctly.</p>

<address>
Kaarel Kaljurand
2013-09-20
</address>

</body>
</html>
