<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Verbalizing OWL in ACE</title>
<meta name="Author" content="Kaarel Kaljurand"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<script type="text/javascript" src="http://attempto.ifi.uzh.ch/site/script/toc.js"></script>
<link rel="stylesheet" title="default" href="http://attempto.ifi.uzh.ch/site/css/ace.css" media="screen" type="text/css"/>

<style type="text/css">
.form { border: silver 1px solid; background-color: #fff090; padding: 0em 1em 0em 1em }
.formitem { border: silver 1px solid; background-color: #ffe090; padding: .2em .2em .2em .2em }
</style>
</head>


<body onload="toc(1, 0)">

<h1>Verbalizing OWL in ACE</h1>

<h2>Introduction</h2>

<p>This document describes how an ontology that is written in
<a href="http://www.w3.org/TR/owl2-xml-serialization/">OWL 2 XML</a> is
verbalized in Attempto Controlled English (ACE).
This conversion is designed to be reversible, i.e.
one can convert the ACE representation back into OWL so that no loss in meaning
occurs.</p>


<h2>Try it out!</h2>

<div class="form">
<!-- <form action="http://attempto.ifi.uzh.ch/service/owl_verbalizer/owl_to_ace" method="post"> -->
<form action="http://localhost:8000" method="post">

<p>Enter the content of an OWL 2 ontology. (You can use
<a href="http://owl.cs.manchester.ac.uk/converter/">OWL Syntax Converter</a>
to convert from RDF/XML, Turtle, etc. into OWL 2 XML.)</p>

<div class="formitem">
<textarea name="xml" title="OWL 2 ontology in XML syntax" rows="24" cols="80">
&lt;?xml version="1.0"?>
&lt;Ontology xmlns="http://www.w3.org/2002/07/owl#"
     xml:base="http://org.semanticweb.ontologies/Ontology1256143016364769000"
         xmlns:xml="http://www.w3.org/XML/1998/namespace">

    &lt;Prefix name="story" IRI="http://www.example.org/story.owl#"/>
    &lt;Prefix name="ace_lexicon" IRI="http://attempto.ifi.uzh.ch/ace_lexicon#"/>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:TV_sg"/>
                &lt;IRI>http://www.example.org/story.owl#eat&lt;/IRI>
        &lt;Literal>eats&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:TV_pl"/>
                &lt;IRI>http://www.example.org/story.owl#eat&lt;/IRI>
        &lt;Literal>eat&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:TV_vbg"/>
                &lt;IRI>http://www.example.org/story.owl#eat&lt;/IRI>
        &lt;Literal>eaten&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;AnnotationAssertion>
        &lt;AnnotationProperty abbreviatedIRI="ace_lexicon:CN_pl"/>
                &lt;IRI>http://www.example.org/story.owl#leaf&lt;/IRI>
        &lt;Literal>leaves&lt;/Literal>
    &lt;/AnnotationAssertion>

    &lt;SubClassOf>
        &lt;Class abbreviatedIRI="story:animal"/>
        &lt;ObjectUnionOf>
            &lt;Class abbreviatedIRI="story:cat"/>
            &lt;Class abbreviatedIRI="story:goat"/>
        &lt;/ObjectUnionOf>
    &lt;/SubClassOf>
    &lt;EquivalentClasses>
        &lt;Class abbreviatedIRI="story:goat"/>
        &lt;ObjectAllValuesFrom>
            &lt;ObjectProperty abbreviatedIRI="story:eat"/>
            &lt;Class abbreviatedIRI="story:leaf"/>
        &lt;/ObjectAllValuesFrom>
    &lt;/EquivalentClasses>
    &lt;SubClassOf>
        &lt;Class abbreviatedIRI="story:human"/>
        &lt;ObjectIntersectionOf>
            &lt;Class abbreviatedIRI="story:person"/>
            &lt;ObjectSomeValuesFrom>
                &lt;ObjectProperty abbreviatedIRI="story:own"/>
                &lt;Class abbreviatedIRI="story:automobile"/>
            &lt;/ObjectSomeValuesFrom>
        &lt;/ObjectIntersectionOf>
    &lt;/SubClassOf>
    &lt;SubClassOf>
        &lt;Class abbreviatedIRI="story:human"/>
        &lt;ObjectOneOf>
            &lt;NamedIndividual abbreviatedIRI="story:John"/>
            &lt;NamedIndividual abbreviatedIRI="story:Mary"/>
        &lt;/ObjectOneOf>
    &lt;/SubClassOf>
    &lt;SubClassOf>
        &lt;Class abbreviatedIRI="story:man"/>
        &lt;Class abbreviatedIRI="story:person"/>
    &lt;/SubClassOf>
    &lt;FunctionalObjectProperty>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
    &lt;/FunctionalObjectProperty>
    &lt;InverseFunctionalObjectProperty>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
    &lt;/InverseFunctionalObjectProperty>
    &lt;TransitiveObjectProperty>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
    &lt;/TransitiveObjectProperty>
    &lt;ObjectPropertyDomain>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
        &lt;Class abbreviatedIRI="story:animal"/>
    &lt;/ObjectPropertyDomain>
    &lt;ObjectPropertyRange>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
        &lt;ObjectIntersectionOf>
            &lt;Class abbreviatedIRI="story:food"/>
            &lt;ObjectComplementOf>
                &lt;Class abbreviatedIRI="story:automobile"/>
            &lt;/ObjectComplementOf>
        &lt;/ObjectIntersectionOf>
    &lt;/ObjectPropertyRange>
    &lt;InverseObjectProperties>
        &lt;ObjectProperty abbreviatedIRI="story:hate"/>
        &lt;ObjectProperty abbreviatedIRI="story:eat"/>
    &lt;/InverseObjectProperties>
    &lt;ClassAssertion>
        &lt;Class abbreviatedIRI="story:man"/>
        &lt;NamedIndividual abbreviatedIRI="story:John"/>
    &lt;/ClassAssertion>
    &lt;SubClassOf>
        &lt;ObjectUnionOf>
            &lt;Class abbreviatedIRI="story:apple"/>
            &lt;Class abbreviatedIRI="story:leaf"/>
        &lt;/ObjectUnionOf>
        &lt;Class abbreviatedIRI="story:food"/>
    &lt;/SubClassOf>
&lt;/Ontology>
</textarea>
</div>

<p>Specify whether the output is
plain ACE text (text/plain),
Axiom-Sentences mapping table (text/html), or
tokenized and without lexicon lookup in 2-column CSV (text/plain):</p>

<div class="formitem">
<input type="radio" name="format" value="ace" checked="checked"/> ACE
<input type="radio" name="format" value="html"/> HTML
<input type="radio" name="format" value="csv"/> CSV
</div>

<p>... and press <input type="submit" value="Verbalize" title="Verbalize the ontology!"/></p>
</form>

<p>There is a 20-second timelimit. In case the ontology cannot be verbalized within
this time-period, an error message is returned.</p>
</div>




<h2>How is the verbalization done?</h2>

<p>We first rewrite the class expressions and axioms via a limited number of
more basic class expressions and axioms. The motivation behind this step is
to replace axioms like</p>

<pre>
ObjectPropertyDomain(R C)
</pre>

<p>which have very little syntactic structure and contain logic-specific words
like `domain'.</p>

<p>The remaining class expressions are mapped to ACE noun phrases and the remaining
axioms to ACE sentences. OWL properties are ACE verbs and OWL individuals are
ACE proper names. The following table shows an example
how the OWL 2 constructs are mapped to ACE constructs.</p>

<table>
	<thead>
		<tr>
			<td>OWL</td>
			<td>ACE</td>
		</tr>
	</thead>

	<tbody>
		<tr>
			<td><em>Named property</em></td>
			<td><em>Transitive verb, e.g.</em> own</td>
		</tr>
		<tr>
			<td>ObjectInverseOf(R)</td>
			<td><em>Passive verb, e.g.</em> is owned by</td>
		</tr>
		<tr>
			<td><em>Named class</em></td>
			<td><em>Common noun, e.g.</em> person</td>
		</tr>

		<tr>
			<td>owl:Thing</td>
			<td>something, thing, X, Y, ...</td>
		</tr>

		<tr>
			<td>ObjectComplementOf(C)</td>
			<td>something that <b>is not</b> a person; something that <b>does not</b> own a car</td>
		</tr>

		<tr>
			<td>ObjectIntersectionOf(C1 ... Cn)</td>
			<td>something that is a person <b>and</b> that owns a car</td>
		</tr>

		<tr>
			<td>ObjectUnionOf(C1 ... Cn)</td>
			<td>something that is a wild-animal <b>or</b> that is a zoo-animal</td>
		</tr>

		<tr>
			<td>ObjectOneOf(a)</td>
			<td><em>Proper name, e.g.</em> John</td>
		</tr>

		<tr>
			<td>ObjectSomeValuesFrom(R C)</td>
			<td>something that owns <b>a</b> car</td>
		</tr>

		<tr>
			<td>ObjectHasSelf(R)</td>
			<td>something that likes <b>itself</b></td>
		</tr>

		<tr>
			<td>ObjectMinCardinality(n R C)</td>
			<td>something that borders <b>at least 2</b> countries</td>
		</tr>

		<tr>
			<td>SubClassOf(C D)</td>
			<td><b>Every</b> country that borders no bodies-of-water <b>is</b> a landlocked-country.</td>
		</tr>

		<tr>
			<td>SubObjectPropertyOf(ObjectPropertyChain(R1 ... Rn) S)</td>
			<td><b>If</b> X owns something that is-part-of Y <b>then</b> X owns Y.</td>
		</tr>

		<tr>
			<td>DisjointObjectProperties(R S)</td>
			<td><b>If</b> X is-child-of Y <b>then</b> <b>it is false that</b> X is-spouse-of Y.</td>
		</tr>
	</tbody>
</table>

<p>ACE allows relative clause coordination and embedding of relative clauses into
other relative clauses. This gives us quite a bit of flexibility in expressing more
complex OWL class expressions. For example,</p>

<pre>
ObjectSomeValuesFrom(eat ObjectComplementOf(ice-cream))
</pre>

<p>would be verbalized as an ACE noun phrase</p>

<pre>
something that eats something that is not an ice-cream
</pre>

<p>Still, verbalizing very complex class expressions would require a support for parentheses which
ACE does not offer. We do not see it as a shortcoming, rather it is a natural
restriction on the complexity of class expressions (which should be readable for
others to understand).</p>

<p>Finally, we apply some simple modifications to make the sentences more
readable, e.g. we try to remove negations and reorder the elements in coordination.</p>


<h2>OWL entities vs ACE content words</h2>

<p>The quality of the verbalization depends somewhat on the morphologic and orthographic
nature of the names
used for individuals, classes and properties in the input ontology. The verbalization assumes
that all individuals are denoted by singular proper names (preferably capitalized),
classes by singular common nouns, and properties by transitive verbs in
their infinitive form.
Examples of individual names are `John', `London'; examples of class names
are `person', `body-of-water'; examples of property names are `own', `border', `look-at'.</p>

<p>These restrictions are needed because the names will be used in certain
syntactic constructions or will undergo certain morphological changes.</p>

<ul>
<li>Individuals (proper names) are used in the subject and object positions
without a determiner, e.g. "Every man knows <b>John</b>.",
"<b>John</b> is a man."</li>
<li>Classes (common nouns) are used in the subject and object positions with
determiners like <i>every</i>, <i>no</i>, <i>a</i>, <i>at least 2</i>;
e.g. "Every <b>man</b> knows something.",
"No <b>woman</b> likes a <b>spider</b>.",
"Every <b>baltic-state</b> borders at least 2 <b>countries</b>.".</li>
<li>Properties (transitive verbs) are often used in singular, e.g.
"Every boy <b>owns</b> a bike.", but under negation (i.e. <em>ObjectComplementOf</em>)
will stay in infinitive, e.g. "Every one-year-old is a child that does not <b>own</b> a bike.".
In some cases, most often when verbalizing the <em>ObjectPropertyRange</em>-construct,
a past participle form is used in order to construct a passive sentence, e.g.
"Everything that is <b>owned</b> by something is a possession."</li>
</ul>

<p>The default morphologic synthesis of plural nouns, 3rd person singular
verbs (e.g. `owns') and past participles (e.g. `owned') is rather naive,
but one can add annotations to the input ontology
to specify the desired surface form, e.g.</p>

<pre>
&lt;AnnotationAssertion> 
	&lt;AnnotationProperty IRI="http://attempto.ifi.uzh.ch/ace_lexicon#CN_pl"/>
	&lt;IRI>#man&lt;/IRI>
	&lt;Literal>men&lt;/Literal>
&lt;/AnnotationAssertion>
</pre>

<p>The following annotation properties are supported:</p>

<table>
	<thead>
		<tr>
			<td>Annotation property IRI</td>
			<td>Meaning</td>
			<td>Example IRI</td>
			<td>Example literal</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#PN_sg</code></td>
			<td>singular form of a proper name</td>
			<td>#John</td>
			<td>John</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#CN_sg</code></td>
			<td>singular form of a common noun</td>
			<td>#man</td>
			<td>man</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#CN_pl</code></td>
			<td>plural form of a common noun</td>
			<td>#man</td>
			<td>men</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#TV_sg</code></td>
			<td>singular form of a transitive verb</td>
			<td>#man</td>
			<td>mans</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#TV_pl</code></td>
			<td>plural form of a transitive verb</td>
			<td>#man</td>
			<td>man</td>
		</tr>
		<tr>
			<td><code>http://attempto.ifi.uzh.ch/ace_lexicon#TV_vbg</code></td>
			<td>past participle form a transitive verb</td>
			<td>#man</td>
			<td>manned</td>
		</tr>
	</tbody>
</table>


<h2>Known limitations</h2>

<p>[BUG: migrate this to the Google Code issues list]</p>

<ul>
<li>Some OWL 2 logical constructs are not supported, namely:
top/bottom object/data properties,
<em>HasKey</em>,
<em>AnonymousIndividual</em>, and
some data property constructs.</li>

<li>Axioms that contain annotations are rejected.</li>

<li>All white-space in the input XML-file is normalized,
e.g. newlines inside annotations will be mapped to spaces.</li>

<li>The OWL 2 XML processor has been tested only on the files generated by Protege 4.1.</li>

<li>The input OWL 2 XML cannot have elements/attributes from other namespaces than OWL.</li>

<li>"Namespaces" are not supported. I.e. only the substring that comes after the #-sign
in the IRI is preserved. This means that different IRIs that share this substring are
not verbalized as different.</li>

<li>Very complex class descriptions are rejected, i.e. they are not verbalized.</li>

<li>DisjointClasses and other similar list/set constructs could be handled in a shorter way.</li>

<li>Only the logical content of an OWL ontology is verbalized,
and not the information about annotations, versioning, import-structure, etc.</li>
</ul>


<h2>Source code etc.</h2>

<p>The source code, issue list, documentation etc. of the OWL verbalizer
are available at
<a href="http://code.google.com/p/owlverbalizer/">code.google.com/p/owlverbalizer/</a>.</p>

<address>
Kaarel Kaljurand
2011-06-09
</address>

</body>
</html>
